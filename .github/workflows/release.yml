name: Release
run-name: (${{ github.event.inputs.project }}) Release ${{ github.event.inputs.targetVersion }} from ${{ github.ref_name }}

concurrency: production

on:
  workflow_dispatch:
    inputs:
      project:
        description: 'Select the project to release'
        required: true
        type: choice
        default: cli
        options:
          - cli
          - extension
      targetVersion:
        description: 'Version to release (e.g. 1.0.0)'
        type: string
        required: true
      publishRelease:
        description: 'Trigger the publisher Job after a successful release to publish artifacts to remote registries (VSCode, NPM, ...)'
        required: true
        type: boolean
        default: false
      dryRun:
        description: 'Dry-run job to avoid commiting changes and publishing'
        required: true
        type: boolean
        default: false

jobs:
  release:
    timeout-minutes: 15
    environment: production
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      git_tag: ${{ steps.commit.outputs.git_tag }}
      commit_sha: ${{ steps.commit.outputs.commit_sha }}

    steps:
      - name: Echo inputs
        run: |
          echo "Project: $PROJECT"
          echo "Version: $VERSION"
          echo "Publish: $PUBLISH"
          echo "Dry Run: $DRY_RUN"
        env:
          PROJECT: ${{ inputs.project }}
          VERSION: ${{ inputs.targetVersion }}
          PUBLISH: ${{ inputs.publishRelease }}
          DRY_RUN: ${{ inputs.dryRun }}

      - name: Clone
        uses: actions/checkout@v4

      - name: Setup Node.js 22
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Create or Update Release Branch
        run: |
          git config user.name "${{ github.actor }}"
          git config user.email "${{ github.actor }}@users.noreply.github.com"

          # Extract major.minor from version (e.g., 1.2.3 -> 1.2)
          VERSION="${{ inputs.targetVersion }}"
          MAJOR_MINOR=$(echo "$VERSION" | cut -d. -f1,2)
          BRANCH_NAME="release/${{ inputs.project }}/v${MAJOR_MINOR}"

          echo "Target version: $VERSION"
          echo "Release branch: $BRANCH_NAME"

          # Fetch remote branches to check if release branch exists
          git fetch origin

          # Check if branch exists remotely
          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
            echo "Branch $BRANCH_NAME already exists, checking it out..."
            git checkout -B "$BRANCH_NAME" "origin/$BRANCH_NAME"
          else
            echo "Creating new branch $BRANCH_NAME..."
            git checkout -b "$BRANCH_NAME"
          fi

          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV

      - name: Bump Version
        run: npm version ${{ inputs.targetVersion }}
        working-directory: ./packages/${{ inputs.project }}

      - name: Bump Agent Version (when releasing CLI)
        if: inputs.project == 'cli'
        run: npm version ${{ inputs.targetVersion }}
        working-directory: ./packages/agent

      - name: Install dependencies
        run: npm ci

      - name: Check
        run: npm run check:${{ inputs.project }}

      - name: Test
        # For now, skip tests on the VSCode Extension
        if: inputs.project == 'cli'
        run: npm run test:${{ inputs.project }}

      - name: Build
        run: npm run build:${{ inputs.project }}

      - name: Package
        run: npm run package:${{ inputs.project }}

      - name: (Dry Run) Commit and tag
        if: inputs.dryRun == true
        run: echo "Skipping commit and tag phase."

      - name: Commit and tag
        if: inputs.dryRun == false
        id: commit
        env:
          REPO_NAME: 'rover'
          VERSION: '${{ inputs.targetVersion }}'
          PROJECT: '${{ inputs.project }}'
          TAG_NAME: '${{ inputs.project }}/v${{ inputs.targetVersion }}'
        run: |
          git add .
          if [ "$PROJECT" == "cli" ]; then
            git commit -m "release: bump cli and agent to $VERSION"
          else
            git commit -m "release: bump $PROJECT to $VERSION"
          fi
          COMMIT_SHA=$(git rev-parse HEAD)
          echo "COMMIT_SHA=$COMMIT_SHA" >> $GITHUB_ENV
          echo "Created commit: $COMMIT_SHA"
          git tag -a "$TAG_NAME" -m "$TAG_NAME"
          git push origin "${{ env.BRANCH_NAME }}"
          git push --tags
          echo "git_tag=$TAG_NAME" >> "$GITHUB_OUTPUT"
          echo "commit_sha=$COMMIT_SHA" >> "$GITHUB_OUTPUT"

      - name: (Dry Run) Create the release
        if: inputs.dryRun == true
        run: echo "Skipping create release phase."

      - name: Create the release
        if: inputs.dryRun == false
        env:
          GH_TOKEN: ${{ github.token }}
          TAG_NAME: '${{ inputs.project }}/v${{ inputs.targetVersion }}'
        run: |
          # Find the artifact based on the project type
          if [ "${{ inputs.project }}" == "cli" ]; then
            ARTIFACT=$(find ./packages/cli -name "*.tgz" -type f | head -1)
          elif [ "${{ inputs.project }}" == "extension" ]; then
            ARTIFACT=$(find ./packages/extension -name "*.vsix" -type f | head -1)
          fi

          # Create release with artifact
          gh release create "$TAG_NAME" \
            --title "${{ inputs.project }} v${{ inputs.targetVersion }}" \
            --generate-notes \
            --target "${{ env.COMMIT_SHA }}" \
            "$ARTIFACT"

      - name: Notify Google Chat on Success
        if: success() && inputs.dryRun == false
        env:
          WEBHOOK_URL: ${{ secrets.GOOGLE_CHAT_WEBHOOK }}
          PROJECT: ${{ inputs.project }}
          VERSION: ${{ inputs.targetVersion }}
          TAG_NAME: '${{ inputs.project }}/v${{ inputs.targetVersion }}'
          RELEASE_URL: 'https://github.com/${{ github.repository }}/releases/tag/${{ inputs.project }}/v${{ inputs.targetVersion }}'
        run: |
          curl -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d @- <<EOF
          {
            "text": "ðŸš€ *New Release Published*\n\n*Project:* ${PROJECT}\n*Version:* v${VERSION}\n*Tag:* ${TAG_NAME}\n*Release URL:* ${RELEASE_URL}\n*Repository:* ${{ github.repository }}\n*Released by:* ${{ github.actor }}"
          }
          EOF

      - name: Notify Google Chat on Failure
        if: failure() && inputs.dryRun == false
        env:
          WEBHOOK_URL: ${{ secrets.GOOGLE_CHAT_WEBHOOK }}
          PROJECT: ${{ inputs.project }}
          VERSION: ${{ inputs.targetVersion }}
          WORKFLOW_URL: 'https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}'
        run: |
          curl -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d @- <<EOF
          {
            "text": "âŒ *Release Failed*\n\n*Project:* ${PROJECT}\n*Version:* v${VERSION}\n*Repository:* ${{ github.repository }}\n*Failed by:* ${{ github.actor }}\n*Workflow Run:* ${WORKFLOW_URL}\n\nPlease check the workflow logs for details."
          }
          EOF

  build-image:
    needs: release
    if: inputs.project == 'cli' && inputs.dryRun == false && needs.release.result == 'success'
    uses: ./.github/workflows/build-image.yml
    with:
      tag: v${{ inputs.targetVersion }}
      ref: ${{ needs.release.outputs.git_tag }}
    permissions:
      contents: read
      packages: write
    secrets: inherit

  publish:
    needs: [release, build-image]
    if: always() && needs.release.result == 'success' && (needs.build-image.result == 'success' || needs.build-image.result == 'skipped') && inputs.publishRelease == true && inputs.dryRun == false
    uses: ./.github/workflows/publish.yml
    with:
      project: ${{ inputs.project }}
      version: ${{ inputs.targetVersion }}
      dryRun: false
    secrets:
      NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
      VSCODE_MARKETPLACE_TOKEN: ${{ secrets.VSCODE_MARKETPLACE_TOKEN }}
      GOOGLE_CHAT_WEBHOOK: ${{ secrets.GOOGLE_CHAT_WEBHOOK }}
